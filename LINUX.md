<!-- TOC -->

- [1 系统文件的原理](#1-系统文件的原理)
- [2 硬链接和软连接](#2-硬链接和软连接)
    - [2.1 建立方法](#21-建立方法)
    - [2.2 软链接](#22-软链接)
    - [2.3 硬链接](#23-硬链接)
- [3 LINUX常使用命令](#3-linux常使用命令)
    - [3.1 常用命令](#31-常用命令)
    - [3.2 系统管理命令](#32-系统管理命令)
- [4 僵尸程序和孤儿程序](#4-僵尸程序和孤儿程序)
    - [4.1 僵尸程序](#41-僵尸程序)
    - [4.2 孤儿进程](#42-孤儿进程)
    - [4.3 防止僵尸进程](#43-防止僵尸进程)

<!-- /TOC -->
# 1 系统文件的原理
LINUX以文件的形式对计算机中的数据和硬件资源进行管理，也是彻底的一切皆文件，反映在LINUX的文件类型中包括：普通文件、目录文件（文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信接口）。LINUX使用目录树进行管理，是根目录（/），向下成分支的一种文件结构。
# 2 硬链接和软连接
## 2.1 建立方法
* 软链接：ln -s 源文件 目标文件
* 硬链接：ln 源文件 目标文件
## 2.2 软链接
* 软连接可以理解快捷方式，和windows下的快捷方式的作用是一样的。
* 软连接文件的大小和创建时间和源文件不同。软链接文件只是维持从软链接到源文件的一个指向关系。
* 删除源文件，软链接同样也会被删除。
## 2.3 硬链接
* 硬链接等同于cp -p 加同步更新；
* 硬链接的创建时间和大小和源文件一样，相同于是copy了一份。copy命令乳沟不加-p，copy文件的创建时间是复制时间，所以加-p后创建时间和源文件一致。同时硬链接会同步修改源文件（反向也可以），所以硬链接=cp -p加同步更新。
* 删除源文件并不会删除硬链接文件，因为硬链接文件和源文件i节点号（i节点是文件和目录的唯一标识）相同，并且一个i节点可以对应多个文件名，删除源文件只是删除了一个i节点到源文件的映射关系。
# 3 LINUX常使用命令
## 3.1 常用命令
* ls 显示文件或目录
 -l 列出文件详细信息
 -a 列出当前目录下所有文件及目录，包括隐藏文件
* mkdir 创建目录
 -p 创建目录，如果没有父目录，则创建父目录
* cd 切换目录
* touch 创建空文件
* echo 创建带有内容的文件 
```
echo "It is a test" > myFile
```
* cat 查看文件内容
* cp 拷贝
* mv 移动或重命名文件
* rm 删除文件
 -r 递归删除，删除子目录及文件
 -f 强制删除
* find 在文件系统中查找某文件
* wc 统计文本中行数、字数和字符数
```
$ wc testfile           # testfile文件的统计信息  
3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 
```
* grep 在文本中查找某个字符串
* rmdir 删除空目录
* tree 树形显示目录，需要安装tree包
* pwd 显示当前目录
* ln 创建链接文件
## 3.2 系统管理命令
* stat 显示指定文件的详细信息，比ls更详细
* who 显示在线登录用户
* top 动态显示当前耗费资源最多进程信息
* ps 显示瞬时进程状态 ps -aux
* du 查看目录大小
* df 查看磁盘大小
* ifconfig 查看网络情况
* ping 测试网络连通
* netstat 显示网络状态
* man 命令提示 例如查看命令ls用法 man ls
* kill 杀死进程
* shutdown 
 -r 关机重启
 -h 关机不重启
 now 立刻关机
 * reboot 重启

# 4 僵尸程序和孤儿程序
## 4.1 僵尸程序
* 僵尸程序：即子进程先于父进程退出后，子进程的PCB需要父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程称为僵尸进程，僵尸进程实际是一个已经死掉的进程。
* 一个进程在调用exit命令结束自己的生命时，并没有真正的被销毁而是留下了一个被称为僵尸进程（Zombie）的数据结构。僵尸进程几乎放弃了所有的内存空间，也没有可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息。僵尸进程需要父进程为他收尸，如果此时父进程结束了，init进程自动接收该进程为他收尸。他如果父进程是一个循环，僵尸进程会一直保持，大量的僵尸进程会消耗大量的系统资源。
## 4.2 孤儿进程
* 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程收养（进程号为1号）。
* 子进程死亡需要父进程来处理，那么意味着正常状态下子进程应该先于父进程死亡。当父进程死亡先于子进程死亡时，子进程死亡没有父进程处理，这个死亡的子进程就是孤儿进程。
* 但孤儿进程于僵尸进程不同，系统会帮助父进程回收孤儿进程。所以孤儿进程实际上是不占用资源的，不想僵尸进程那这样占用ID，损害进程。
## 4.3 防止僵尸进程
一般，为了防止产生僵尸进程，在fork子进程之后我们都要wait它们；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。