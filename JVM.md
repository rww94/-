<!-- TOC -->

- [1 Jvm数据区域](#1-jvm数据区域)
- [2 垃圾回收方法](#2-垃圾回收方法)
    - [2.1 判断对象已经可以被回收](#21-判断对象已经可以被回收)
        - [2.1.1 引用计数法](#211-引用计数法)
        - [2.1.2 可达性分析](#212-可达性分析)
        - [2.1.3 回收方法区](#213-回收方法区)
    - [2.2 垃圾回收算法](#22-垃圾回收算法)
        - [2.2.1 标记-清除算法](#221-标记-清除算法)
        - [2.2.2 复制算法](#222-复制算法)
        - [2.2.3 标记-整理算法](#223-标记-整理算法)
        - [2.2.4 分代回收](#224-分代回收)
    - [2.3 GC触发时机](#23-gc触发时机)
- [3 对象内存分配](#3-对象内存分配)
    - [3.1 对象优先分配在Eden](#31-对象优先分配在eden)
    - [3.2 大对象将直接进入老年代](#32-大对象将直接进入老年代)
    - [3.3 长期存活的对象将进入老年代](#33-长期存活的对象将进入老年代)
- [4 类加载机制](#4-类加载机制)
    - [4.1 类的声明周期](#41-类的声明周期)
        - [4.1.1 加载](#411-加载)
        - [4.1.2 验证](#412-验证)
        - [4.1.3 准备](#413-准备)
        - [4.1.4 解析](#414-解析)
        - [4.1.5 初始化](#415-初始化)
        - [4.1.6 使用和卸载](#416-使用和卸载)
    - [4.2 双亲委派模型](#42-双亲委派模型)
- [5 Java内存模型（JMM）](#5-java内存模型jmm)
- [6 Java虚拟机的平台无关性和语言无关性](#6-java虚拟机的平台无关性和语言无关性)
    - [6.1 Java程序可以跨平台运行的原因](#61-java程序可以跨平台运行的原因)
    - [6.2 Java语言无关性的原因](#62-java语言无关性的原因)
- [7 JVM发生内存泄漏的原因](#7-jvm发生内存泄漏的原因)
    - [7.1 静态集合类引起内存泄漏](#71-静态集合类引起内存泄漏)
    - [7.2 当集合里面的对象属性被修改后，再调用remove（）方法时不起作用](#72-当集合里面的对象属性被修改后再调用remove方法时不起作用)
    - [7.3 监听器](#73-监听器)
    - [7.4 各种连接](#74-各种连接)
    - [7.5 内部类和外部模块的引用](#75-内部类和外部模块的引用)
    - [7.6 单例模式](#76-单例模式)

<!-- /TOC -->
# 1 Jvm数据区域
* 程序计数器：当前线程所执行的字节码的行号指示器，如果线程执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
* Java虚拟机栈：描述的是java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等；
* 本地方法栈：和虚拟机栈类似，不过是为本地Native方法服雾；
* Java堆：存放对象实例，是垃圾回收的主要区域；
* 方法区：用于存储已经被虚拟机加载的类信息、常量、静态常量等数据

方法区和堆是所有线程共享的内存区域。
程序计数器、虚拟机栈和本地方法栈是线程私有，隔离的内存区域。
# 2 垃圾回收方法
&emsp;&emsp;线程私有的程序计数器、虚拟机栈和本地方法栈三个区域随着线程生，随着线程而灭，因此不需要多考虑回收问题。
而java堆和方法区内存的分配是动态的，垃圾回收主要关注的是这部分。
## 2.1 判断对象已经可以被回收
### 2.1.1 引用计数法
&emsp;&emsp;给对象中添加一引用计数器，每当一个地方引用它时，计数器+1，当引用失效时计数器-1，任何计数器为0的对象不可能再被使用；但存在的问题是很难解决对象互相循环引用的问题。
### 2.1.2 可达性分析
&emsp;&emsp;基本思想是通过一系列被称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象不可达
### 2.1.3 回收方法区
方法区（永久代）一般不要求回收垃圾，因为方法与的垃圾回收效率低。
永久代的垃圾回收主要包括：废弃常量和无用的类（类信息回收）。
回收废弃常量和回收Java堆中的类似，当没有地方引用这个常量是回发生回收；
而回收类要满足的条件要相对复杂：
1、该类的所有实例对象已经被回收；
2、该类的ClassLoader已经被回收；
3、该类对应的java.lang.class没有地方引用，即不能通过反射来访问类。
## 2.2 垃圾回收算法
新生代占堆的1/3，老年代占堆的2/3；其中Eden占新生代的8/10，from占1/10，to占1/10；
### 2.2.1 标记-清除算法
算法分为两步：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象；
主要不足所有两点：1效率不高；2标记清除后会产生大量不连续的内存碎片。
### 2.2.2 复制算法
复制算法用于新生代，因为适用于对象的存活率较低的区域；
将新生代内存划分为Eden和两块较小的Survivor区域，每次只使用Eden和一块Survivor。当回收时将这两块区域中活着的对象一次性复制到另一块Survivor中。如果Survivor不够用时，需要老年代进行分配担保。
### 2.2.3 标记-整理算法
同样先需要进行标记回收对象，但后续不是直接对可回收对象进行处理，而是让存活的对象都向一端移动，然后清除掉边界外的内存。
### 2.2.4 分代回收
新生代：每次回收都有大量对象死去，所以使用复制算法；
老年代：对象存活率较高，没有额外空间进行分配担保，必须使用标记-清除和标记-整理算法。
## 2.3 GC触发时机
* 1）程序条用System.gc时触发
* 2）系统自身决定触发：根据Eden区和Form space区的内存大小，当Eden没有足够的空间进行分配时虚拟机将发起一次Minor GC。Full GC回收老年代。


# 3 对象内存分配
&emsp;&emsp;对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，会按线程优先在TLAB（Thread Local &emsp;&emsp;Allocation Buffer）分配。少数情况下会直接分配在老年代。
## 3.1 对象优先分配在Eden
&emsp;&emsp;大部分情况下，对象新生代Eden去中分配。当Eden区中没有足够的空间进行分配时，虚拟机将触发一次Minor GC；
## 3.2 大对象将直接进入老年代
&emsp;&emsp;大对象指需要大量连续内存空间的java对象，典型的大对象就是那种很长的字符串以及数组；
## 3.3 长期存活的对象将进入老年代
&emsp;&emsp;虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过一次Minor GC后被移动到Survivor中，设置年龄为1.然后每在Survivor中经过一次Minor GC存活年龄就+1，当它的年龄增长的一定程度（默认为15）将被晋升为老年代。
# 4 类加载机制
## 4.1 类的声明周期
&emsp;&emsp;加载、验证、准备、解析、初始化、使用和卸载
### 4.1.1 加载
加载时类加载过程中的一个阶段，在加载阶段，虚拟机完成三件事：
* 1）通过类的全限定名来获取定义此类的二进制字节流；
* 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
* 3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口.
### 4.1.2 验证
这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面4个阶段的检验动作：
* 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理；
* 元数据验证：对字节码描述的信息进行语义分析，确保其描述的信息符合Java语言规范的要求，包括类是否有父类
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
* 符号引用验证：虚拟机将符号引用转化为直接引用时。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。
### 4.1.3 准备
准备阶段是正式将类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
* 这里进行内存分配的进包括类变量（被static修饰的变量），而不包括实例变量；实例变量将随对象实例化时分配在java堆上；
* 这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
```java
    public static int value = 123;
```
那value值在准备阶段的初始值是0而不是123，把value赋值为123的动作将在初始化阶段执行。
假设类变量定义为：
```java
    public static final int value = 123;
```
那么编译时Java将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue将value赋值为123.
### 4.1.4 解析
解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
### 4.1.5 初始化
初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户可以通过自定义类加载器参与外，都是完全由虚拟机主导和控制。在初始化阶段，真正开始执行Java程序代码。初始化阶段是执行类构造器<clinit>()方法的过程。
### 4.1.6 使用和卸载
## 4.2 双亲委派模型
&emsp;&emsp;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
双亲委派模型的工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层析的类加载器都如此，这样所有的加载请求都会传送到顶层的启动类加载器，只有父加载器反馈自己无法完成加载时，子加载器才会尝试自己加载。

# 5 Java内存模型（JMM）
&emsp;&emsp;JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据。而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，线程间的通信(传值)必须通过主内存来完成。

# 6 Java虚拟机的平台无关性和语言无关性
## 6.1 Java程序可以跨平台运行的原因
* 平台无关性，所有虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。
* Java程序不是直接运行在电脑上，而是在虚拟机上运行，每个系统平台都有自己的虚拟机（JVM），java想把java文件编译成二进制class文件，jvm解释执行class文件。
## 6.2 Java语言无关性的原因
* 实现语言无关性的基础是虚拟机和字节码存储格式。
* Java虚拟机不和包括Java在内的任何语言绑定，它之和“class文件”这个特殊的二进制文件格式所关联，class文件中包含了java虚拟机指令集和符号表以及若干其他信息。
* 任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的class文件。



# 7 JVM发生内存泄漏的原因
&emsp;&emsp;长生命周期的对象持有短声明周期对象的引用就很有可能发生内存泄漏，尽管短生命周期对象已经不再需要，但因为长生命周期对象持有它的引用而导致不能被回收，这是JAVA中内存泄漏的场景。
## 7.1 静态集合类引起内存泄漏
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 
例: 
```java
    Static Vector v = new Vector(10); 
    for (int i = 1; i<100; i++){ 
        Object o = new Object(); 
        v.add(o); 
        o = null; 
    }
```
在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。
## 7.2 当集合里面的对象属性被修改后，再调用remove（）方法时不起作用
```java
例： 
public static void main(String[] args) { 
    Set<Person> set = new HashSet<Person>(); 
    Person p1 = new Person("唐僧","pwd1",25); 
    Person p2 = new Person("孙悟空","pwd2",26); 
    Person p3 = new Person("猪八戒","pwd3",27); 
    set.add(p1); 
    set.add(p2); 
    set.add(p3); 
    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! 
    p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 

    set.remove(p3); //此时remove不掉，造成内存泄漏
    set.add(p3); //重新添加，居然添加成功 
    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! 
    for (Person person : set) { 
        System.out.println(person); 
    } 
}
```
## 7.3 监听器
&emsp;&emsp;在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。
## 7.4 各种连接
&emsp;&emsp;比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。
## 7.5 内部类和外部模块的引用
&emsp;&emsp;内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： 
```java
    public void registerMsg(Object b); 
```
这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。
## 7.6 单例模式
&emsp;&emsp;不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。
```java
class A{ 
    public A(){ 
        B.getInstance().setA(this); 
    } 
.... 
} 
//B类采用单例模式 
class B{ 
    private A a; 
    private static B instance=new B(); 
    public B(){} 
    public static B getInstance(){ 
       return instance; 
    } 
    public void setA(A a){ 
        this.a=a; 
    } 
    //getter... 
} 
```
显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况
