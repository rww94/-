<!-- TOC -->

- [1 数据库事务的特征](#1-数据库事务的特征)
- [2 数据库并发问题](#2-数据库并发问题)
    - [2.1 Dirty Reads（脏读）](#21-dirty-reads脏读)
    - [2.2 Unrepeatable Reads（不可重复读）](#22-unrepeatable-reads不可重复读)
    - [2.3 Phantom Reads (幻象读)](#23-phantom-reads-幻象读)
- [3 数据库事务的隔离级别](#3-数据库事务的隔离级别)
    - [3.1 Read Uncommitted（读取未提交）](#31-read-uncommitted读取未提交)
    - [3.2 Read Committed（读取提交内容）](#32-read-committed读取提交内容)
    - [3.3 Repeatable Read（可重读）](#33-repeatable-read可重读)
    - [3.4 Serializeble（可串行化）](#34-serializeble可串行化)
- [4 数据库索引](#4-数据库索引)
    - [4.1 索引的底层原理](#41-索引的底层原理)
    - [4.2 索引对数据库优缺点](#42-索引对数据库优缺点)
        - [4.2.1 索引的优点](#421-索引的优点)
        - [4.2.2 索引的缺点](#422-索引的缺点)
    - [4.3 建立索引的原则](#43-建立索引的原则)
    - [4.4 索引的实现方式](#44-索引的实现方式)
- [5 MySQL常见的存储引擎](#5-mysql常见的存储引擎)
- [6 数据库视图和临时表](#6-数据库视图和临时表)
- [7 如何解决数据库高并发](#7-如何解决数据库高并发)
    - [7.1 路径要短](#71-路径要短)
    - [7.2 查询数据要少](#72-查询数据要少)
    - [7.3 分流](#73-分流)
- [8 查询语句不同元素执行顺序](#8-查询语句不同元素执行顺序)

<!-- /TOC -->
# 1 数据库事务的特征
* Atomic（原子性）
事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
* Consistency（一致性）
只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
* Isolation（隔离性）
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。 
* Durability（持久性）
事务结束后，事务处理的结果必须能够得到固化。

在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。
# 2 数据库并发问题
## 2.1 Dirty Reads（脏读）
* 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚;
* A事务读取了B事务尚未提交的更改数据，并且在这个数据基础上进行操作。如果此时恰巧B事务进行回滚，那么A事务读到的数据是根本不被承认的。
## 2.2 Unrepeatable Reads（不可重复读）
* 一个事务对同一行数据重复读取两次，但是却得到了不同的结果；
* 不可重复读是指A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致。
## 2.3 Phantom Reads (幻象读)
* 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的；
* A事务读取B提交的新增数据，这时A事务将出现幻想读的问题。幻读一般发生在计算统计数据的事务中。举个例子，假设银行系统在同一个事务中两次统计存款的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时两次统计的总金额将不一致。
# 3 数据库事务的隔离级别
## 3.1 Read Uncommitted（读取未提交）
* set tx_isolation='READ-UNCOMMITTED';
* 事务最低的隔离级别，它允许另外一个事务读取到这个事务未提交的数据；
* 产生脏读，不可重复读，幻读。
## 3.2 Read Committed（读取提交内容）
* set tx_isolaton='read-committed';
* 大多数数据库系统的默认隔离级别（但不是Mysql默认的，是SQL Server的）；
* 满足隔离的简单定义：一个事务只能看见已提交事务所做的改变；
* 可能产生不可重复读和幻读问题。
* 解决不可重复读的问题只需锁住满足条件的行。
## 3.3 Repeatable Read（可重读）
* set tx_ioslation='repeatable-read';
* 是Mysql的默认事务隔离级别；
* 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行；
* 可能会产生幻读，当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行；
* InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。
* 解决幻读需要锁表。
## 3.4 Serializeble（可串行化）
* set tx_isolation='serializable';
* 事务的最高隔离级别；
* 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁；
* 在这个级别，可能导致大量的超时现象和锁竞争

# 4 数据库索引
## 4.1 索引的底层原理
使用经过优化的B+树实现，主要是所有的叶子结点增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。
* Hash索引：hash索引，等价查询效率高，不能排序，不能进行范围查询；
* B+索引：数据有序，范围查询。
<br/>

* 聚集索引：数据按索引顺序存储，子节点存储的真实的物理数据；
* 非聚集索引：存储指向真正数据行的指针。
* 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。
* 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。
* 非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。
## 4.2 索引对数据库优缺点
### 4.2.1 索引的优点
* 快速访问数据库表中的特定信息，提高检索速度；
* 创建唯一性索引，保证数据库表中每一行的数据的唯一性；
* 加速表与表之间的连接；
* 使用分组和排序子句进行数据索引时，可以显著的减少查询中分组和排序的时间。
### 4.2.2 索引的缺点
* 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；
* 索引需要占物理空间，不光表需要占用数据空间，每个索引也要占物理空间；当对表进行增删修改的时候索引也要进行动态维护，这样降低了数据的维护速度。
## 4.3 建立索引的原则
* 在最频繁使用的，用来缩小查询范围的字段上建立索引；
* 在频繁使用的，需要排序的字段建立索引。
* 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；
* 对于一些特殊的数据类型，不宜建立索引，比如文本（Text）字段。
## 4.4 索引的实现方式
* 针对一张表的某些字段建立具体的索引
* 在创建表时为字段建立主键约束或唯一索引，系统将自动为其建立索引。

# 5 MySQL常见的存储引擎
MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以选用InnoDB、MyISAM、MEMORY，BDB(BerkeleyDB、EXAMPLE、FEDERATED、ARCHIVE、CSV等，常用的是InnoDB和MyISAM两种；
他们两个的区别大致表现为：
* InnoDB支持事务，MyISAM不支持事务；
* MyISAM适合查询已插入为主的应用；
* InnoDB适合频繁修改以及涉及到安全性较高的应用；
* InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；
* INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持；
* MyISAM的性能更优，占用的存储空间少。  
# 6 数据库视图和临时表
视图是一个预编译的sql语句，不保存实际的数据，而临时表是保存在tempdb中的实际的表。
视图的应用场景：
* 保密工作，比如有一个员工工资表，如果你只希望财务看到员工工资这个字段，其他人不能看到工资字段，那就用一个视图，把工资这个敏感字段过滤掉;
* 查询方面可以充当一个变量角色：当一个查询语句非常复杂，大概有100行这么多，还要和其他表关联得到结果，可以用一个视图来代替这100行的select语句。
```sql
--创建视图--
create or replace view v_student as select * from student;
--从视图中检索数据--
select * from v_student;
--删除视图--
drop view v_student;
```
临时表常用sql语句
```sql
1、创建临时表
(1)定义字段
CREATE TEMPORARY TABLE tmp_table (        
name VARCHAR(10) NOT NULL,        
value INTEGER NOT NULL)     
(2)直接将查询结果导入临时表
CREATE TEMPORARY TABLE tmp_table SELECT * FROM table_name
3、查询临时表
select * from tmp_table
4、删除临时表
drop table tmp_table
```
# 7 如何解决数据库高并发
数据库高并发的问题本质在于：一个是慢，一个是等；
解决方案从以下几个方面出发：
## 7.1 路径要短
* 页面静态化：将一些不常用的更新间隔时间长的页面实行静态化；
* 使用缓存：主要针对于数据与用户无直接关联，写少读多的数据，使用缓存来减少数据库的压力，
数据从数据库中获取后，保存在缓存中，以后就可以直接从缓存中加载数据，需要有机制维持缓存和数据库的一致性；
* 使用存储过程：对于那些一次请求需要多次访问数据库的查询合并到一次进行，减少数据库的访问次数；
* 延时修改：高并发情况下，可以把多次修改先保存到缓存中，然后定时将缓存中数据保存到数据库中，风险是可能断电丢失数据。
## 7.2 查询数据要少
* 分表：将一张大表的数据再次细分，但要尽量避免分出的多个表进行关联查询；
* 分离活跃数据：可以将活跃用户数据单独保存在一张表中，查询时先查询活跃表，如果没有再查总表。
## 7.3 分流
* 集群：将并发请求分配到不同的服务器上；
* 分布式：请单次请求的多项业务逻辑分配到多个服务器上
* CDN：域名解析层面的分流,也就是将华南地区的用户请求配给给华南,华中给华中
* 消息队列

# 8 查询语句不同元素执行顺序
查询中用到的关键词主要包含六个，并且他们的顺序依次为 'select'--'from'--'where'--'group by'--'having'--'order by';
其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行:
* from：需要从哪个表检索数据；
* where：过滤表中数据的条件；
* group by：如何将上面过滤的数据进行分组；
* having：对上面已经分组的数据进行过滤的条件；
* select：查看结果集中的哪列，或列的计算结果；
* order by：按照什么样的顺序返回查询结果。




