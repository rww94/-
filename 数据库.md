<!-- TOC -->

- [1 数据库事务的特征](#1-数据库事务的特征)
- [2 数据库并发问题](#2-数据库并发问题)
    - [2.1 Dirty Reads（脏读）](#21-dirty-reads脏读)
    - [2.2 Unrepeatable Reads（不可重复读）](#22-unrepeatable-reads不可重复读)
    - [2.3 Phantom Reads (幻象读)](#23-phantom-reads-幻象读)
- [3 数据库事务的隔离级别](#3-数据库事务的隔离级别)
    - [3.1 Read Uncommitted（读取未提交）](#31-read-uncommitted读取未提交)
    - [3.2 Read Committed（读取提交内容）](#32-read-committed读取提交内容)
    - [3.3 Repeatable Read（可重读）](#33-repeatable-read可重读)
    - [3.4 Serializeble（可串行化）](#34-serializeble可串行化)
- [4 数据库索引](#4-数据库索引)
    - [4.1 索引的底层原理](#41-索引的底层原理)
- [5 MySQL常见的存储引擎](#5-mysql常见的存储引擎)
- [6 数据库临时表](#6-数据库临时表)
- [7 如何解决数据库高并发](#7-如何解决数据库高并发)
    - [7.1 路径要短](#71-路径要短)
    - [7.2 查询数据要少](#72-查询数据要少)
    - [7.3 分流](#73-分流)

<!-- /TOC -->
# 1 数据库事务的特征
* Atomic（原子性）
事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
* Consistency（一致性）
只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
* Isolation（隔离性）
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。 
* Durability（持久性）
事务结束后，事务处理的结果必须能够得到固化。

在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。
# 2 数据库并发问题
## 2.1 Dirty Reads（脏读）
* 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚;
* A事务读取了B事务尚未提交的更改数据，并且在这个数据基础上进行操作。如果此时恰巧B事务进行回滚，那么A事务读到的数据是根本不被承认的。
## 2.2 Unrepeatable Reads（不可重复读）
* 一个事务对同一行数据重复读取两次，但是却得到了不同的结果；
* 不可重复读是指A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致。
## 2.3 Phantom Reads (幻象读)
* 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的；
* A事务读取B提交的新增数据，这时A事务将出现幻想读的问题。幻读一般发生在计算统计数据的事务中。举个例子，假设银行系统在同一个事务中两次统计存款的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时两次统计的总金额将不一致。
# 3 数据库事务的隔离级别
## 3.1 Read Uncommitted（读取未提交）
* set tx_isolation='READ-UNCOMMITTED';
* 事务最低的隔离级别，它允许另外一个事务读取到这个事务未提交的数据；
* 产生脏读，不可重复读，幻读。
## 3.2 Read Committed（读取提交内容）
* set tx_isolaton='read-committed';
* 大多数数据库系统的默认隔离级别（但不是Mysql默认的）；
* 满足隔离的简单定义：一个事务只能看见已提交事务所做的改变；
* 可能产生不可重复读和幻读问题。
* 解决不可重复读的问题只需锁住满足条件的行。
## 3.3 Repeatable Read（可重读）
* set tx_ioslation='repeatable-read';
* 是Mysql的默认事务隔离级别；
* 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行；
* 可能会产生幻读，当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行；
* InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。
* 解决幻读需要锁表。
## 3.4 Serializeble（可串行化）
* set tx_isolation='serializable';
* 事务的最高隔离级别；
* 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁；
* 在这个级别，可能导致大量的超时现象和锁竞争

# 4 数据库索引
## 4.1 索引的底层原理


# 5 MySQL常见的存储引擎
MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以选用InnoDB、MyISAM、MEMORY，BDB(BerkeleyDB、EXAMPLE、FEDERATED、ARCHIVE、CSV等，常用的是InnoDB和MyISAM两种；
他们两个的区别大致表现为：
* InnoDB支持事务，MyISAM不支持事务；
* MyISAM适合查询已插入为主的应用；
* InnoDB适合频繁修改以及涉及到安全性较高的应用；
* InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；
* INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持；
* MyISAM的性能更优，占用的存储空间少。  
# 6 数据库临时表

# 7 如何解决数据库高并发
数据库高并发的问题本质在于：一个是慢，一个是等；
解决方案从以下几个方面出发：
## 7.1 路径要短
* 页面静态化：将一些不常用的更新间隔时间长的页面实行静态化；
* 使用缓存：主要针对于数据与用户无直接关联，写少读多的数据，使用缓存来减少数据库的压力，
数据从数据库中获取后，保存在缓存中，以后就可以直接从缓存中加载数据，需要有机制维持缓存和数据库的一致性；
* 使用存储过程：对于那些一次请求需要多次访问数据库的查询合并到一次进行，减少数据库的访问次数；
* 延时修改：高并发情况下，可以把多次修改先保存到缓存中，然后定时将缓存中数据保存到数据库中，风险是可能断电丢失数据。
## 7.2 查询数据要少
* 分表：将一张大表的数据再次细分，但要尽量避免分出的多个表进行关联查询；
* 分离活跃数据：可以将活跃用户数据单独保存在一张表中，查询时先查询活跃表，如果没有再查总表。
## 7.3 分流
* 集群：将并发请求分配到不同的服务器上；
* 分布式：请单次请求的多项业务逻辑分配到多个服务器上
* CDN：域名解析层面的分流,也就是将华南地区的用户请求配给给华南,华中给华中
* 消息队列
